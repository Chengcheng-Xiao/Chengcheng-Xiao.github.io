I"…Ω<h2 id="background">Background</h2>

<p>Spin texture describes the pattern which k-dependent spin directions formed in the Brillouin zone.</p>

<p>This peculiar phenomena arises from the coupling between spin and orbital motions of electrons ‚Äì spin-orbital coupling (SOC).
Without this coupling, the spin would remain in a ‚Äúcollinear‚Äù state and be rotationally invariant.
However, when the SOC is introduced, spin moments are coupled to the anisotropic orbital degrees of freedom which makes them also anisotropic.
This explains the origin of the magnetic anisotropy and the spin texture as well as other exotic phenomenas in condense matter physics.
A rigorous derivation of the SOC Hamiltonian needs relativistic quantum mechanics with many-body interactions.
However, here, I‚Äôm presenting a simple ‚Äúpictorial‚Äù description of this phenomena:
The orbital motion of electrons generates a magnetic field, and that magnetic field acts on the spin magnetic moment which makes it precess along that magnetic field direction (‚ÄúLarmor‚Äù precession).
This coupling will generate an energy splitting between different spin directions, hence changing the expectation value of the Pauli matrix.</p>

<p>A simple spin orbital Hamiltonian (can be added to the non-SOC Hamiltonian):</p>

\[\textbf{H}_{soc} = \gamma \sigma \cdot L\]

<p>where \(S\) and \(L\) are the spin operator(Pauli matrix) and the angular momentum operator, \(\gamma\) is the spin-orbital coupling strength constant.</p>

<p>The Goal of this tutorial is to show you how to plot the spin texture directly from DFT and how to calculate it from diagonalising the Wanneir Hamiltonian and calculating the spin eigenvalues your self.</p>

<p>You may ask: If we can already get those directly from DFT then why do we need to do it again with Wannier functions?
Well, I can only say it‚Äôs a fun thing to do. And it can be generalised if you want to, say, calculate the spin eigenvalues at specific K-point and Band number for an expended TB Wannier/TB Hamiltonian. (Which is an important thing for the topological peopleü§ì)</p>

<p>In the following sections, I‚Äôll use monolayer \(\mathrm{In}_{2}\mathrm{Se}_3\) as an example to calculate spin texture. Note that because this is a 2D system, I‚Äôm plotting a 2D spin texture. For 3D systems, You can also plot them in 3D. Or you can still use 2D plot by slicing the Brillouin zone.</p>

<h2 id="vasp">VASP</h2>
<h3 id="implementation">Implementation</h3>
<p>VASP only consider the SOC effect in ‚Äúthe immediate vicinity of the nuclei‚Äù which they uses the PAW spheres as the boundary.
This means they have to use the all-electron partial waves to calculate the spin orbital matrix element and subsequently the total add-on energy.
If you take a close look at the source code, you will find the overlap is calculated by sandwiching the overlap operator:</p>

\[\textbf{S} = \textbf{1}+\sum_{ij} Q_{ij} |\beta_{i}&gt;&lt;\beta_{j}|\]

<p>As long as we have the overlap operator, we can dot what ever we like to the Bloch functions!</p>

<h3 id="how-to">How to?</h3>
<p>VASP already provide the projected spin expectation value for each orbital (in x,y,z order) in the <code class="language-plaintext highlighter-rouge">PROCAR</code> file.</p>

<p>we can use <a href="https://github.com/romerogroup/pyprocar"><strong>pyprocar</strong></a> to plot it.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pyprocar</span>
<span class="n">pyprocar</span><span class="p">.</span><span class="n">repair</span><span class="p">(</span><span class="s">'PROCAR'</span><span class="p">)</span> <span class="c1"># usually needed.
</span><span class="n">pyprocar</span><span class="p">.</span><span class="n">fermi2D</span><span class="p">(</span><span class="s">'PROCAR-repaired'</span><span class="p">,</span> <span class="n">outcar</span><span class="o">=</span><span class="s">'OUTCAR'</span><span class="p">,</span> <span class="n">st</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">energy</span><span class="o">=-</span><span class="mf">0.14</span><span class="p">,</span> <span class="n">noarrow</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">code</span><span class="o">=</span><span class="s">'vasp'</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Now, results!</strong></p>

<p class="center"><img src="/assets/img/post_img/2020-06-17-img1.png" alt="" /></p>

<p>This is a 2D plot of the spin texture. The x and y axis are the rec. space vectors (well, not exactly. Since we have a hex cell, but you get the gist) and the arrows are the spin expectation vectors in the x-y plane, and the colour of those arrows correspond to the expectation values on the out of plane z direction.
The cut energy is set to 0.14eV below the fermi level.
As you can clearly see, we have 2 black circle-shaped thingy on the plot.
They correspond to two different bands, and judging by the arrows, we can safely say they correspond to the opposite spin of a single orbital (in ‚Äúcollinear‚Äù sense, spin up and spin down).</p>

<h2 id="wannier90">Wannier90</h2>
<h3 id="implementation-1">Implementation</h3>
<p>In the projection routine, VASP projects the Bloch functions onto a set of pure guiding functions with only one spinor component (this is not necessarily true, I‚Äôve changed this behaviour in my <a href="https://github.com/Chengcheng-Xiao/VASP2WAN90_v2_fix"><strong>fix</strong></a>, allowing one to specify spin quantisation axis, but I guess thats different).
In the mean time, VASP doesn‚Äôt support writing spin matrix element for each k-point and band (yet, I‚Äôll try to implement it in the future).
So if the projection is skewed and we need to mix everything together by doing iterative minimisation (e.g. random projection and a large <code class="language-plaintext highlighter-rouge">num_iter</code>), then, we cannot guarantee the spinor components are well separated and our spin-textures are right.
However, if our initial guess is pretty ‚Äòon-the-spot‚Äô (e.g. we can get perfect band interpolation without iterative minimisation).
We are usually safe to assume that the end results are correct.</p>

<p>On a side note, I found that if the initial guess is good enough, even with some mixing, we can still get good results.</p>

<h3 id="how-to-1">How to?</h3>
<p>You need:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">hr.dat</code> file</li>
  <li><code class="language-plaintext highlighter-rouge">.win</code> file</li>
  <li><code class="language-plaintext highlighter-rouge">\_band*</code> file</li>
</ul>

<p>If you don‚Äôt know how to calculate Wannier functions, click <a href="https://github.com/Chengcheng-Xiao/TB_play"><strong>here</strong></a>!</p>

<p>I‚Äôve decided to use <a href="https://www.physics.rutgers.edu/pythtb/"><strong>pythtb</strong></a> as my diagonalisation tool (I‚Äôm lazy and I use python 2. Yeah, I know, I will port everything to python 3 tomorrow, I promise‚Ä¶)</p>

<p>Since the Hamiltonian and the Pauli matrix commute. After obtained the eigenvectors from diagonalising the Hamiltonian, we can apply the coefficients to the Pauli matrix and obtain the spin expectation value.
As we are still in linear realm, we can sum up every orbitals‚Äô coefficients (with the same spinor component) and apply the Pauli matrix to that big ‚Äòall-in-one‚Äô spinor wavefunction or apply Pauli matrix to each set of spinors for each orbital and added them up.
<strong>Choose you warrior!</strong></p>

<p>It‚Äôs coding time! (I use <a href="https://atom.io/"><strong>Atom</strong></a> and <a href="https://atom.io/packages/hydrogen"><strong>Hydrogen</strong></a> so <code class="language-plaintext highlighter-rouge">#%%</code> has special meaning, check it out!)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
</span>
<span class="kn">from</span> <span class="nn">pythtb</span> <span class="kn">import</span> <span class="o">*</span> <span class="c1"># import TB model class
</span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="c1"># read output from Wannier90 that should be in folder named "example_a"
#   see instructions above for how to obtain the example output from
#   Wannier90 for testing purposes
</span><span class="n">InSe</span><span class="o">=</span><span class="n">w90</span><span class="p">(</span><span class="s">r"output/wannier90"</span><span class="p">,</span><span class="s">r"wannier90"</span><span class="p">)</span>

<span class="c1"># get tight-binding model without hopping terms above 0.01 eV
</span><span class="n">my_model</span><span class="o">=</span><span class="n">InSe</span><span class="p">.</span><span class="n">model</span><span class="p">()</span>
<span class="c1">#%% k_mesh parameters
</span><span class="n">ksize_x</span> <span class="o">=</span> <span class="mi">21</span>
<span class="n">ksize_y</span> <span class="o">=</span> <span class="mi">21</span>
<span class="n">krange</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">origin</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">krange</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="n">krange</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>

<span class="c1">#%% set up k grid
</span><span class="n">k_vec</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">([(</span><span class="n">ksize_x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">ksize_y</span><span class="p">),</span><span class="mi">3</span><span class="p">])</span>
<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ksize_x</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ksize_y</span><span class="p">):</span>
        <span class="n">k_vec</span><span class="p">[</span><span class="n">a</span><span class="o">*</span><span class="n">ksize_x</span><span class="o">+</span><span class="n">b</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">krange</span><span class="o">/</span><span class="n">ksize_x</span><span class="p">),</span><span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">b</span><span class="o">*</span><span class="p">(</span><span class="n">krange</span><span class="o">/</span><span class="n">ksize_y</span><span class="p">),</span><span class="mf">0.0</span><span class="p">]</span>

<span class="c1"># or use automatic generation (1st BZ, 1st quadrant only)
# k_vec = my_model.k_uniform_mesh([ksize_x,ksize_y,1])
</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span><span class="n">evacs</span><span class="p">)</span><span class="o">=</span><span class="n">my_model</span><span class="p">.</span><span class="n">solve_all</span><span class="p">(</span><span class="n">k_vec</span><span class="p">,</span><span class="n">eig_vectors</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1">#%% reordering everything
# reorder kpoints
</span><span class="n">k_vec_new</span> <span class="o">=</span> <span class="n">k_vec</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ksize_x</span><span class="p">,</span><span class="n">ksize_y</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="c1"># reorder evacs, need to swap axis to fortran like...
</span><span class="n">evacs_new</span> <span class="o">=</span> <span class="n">evacs</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">22</span><span class="p">,</span><span class="n">ksize_y</span><span class="p">,</span><span class="n">ksize_x</span><span class="p">,</span><span class="mi">22</span><span class="p">).</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># reorder evals, need to swap axis to fortran like...
</span><span class="n">evals_new</span> <span class="o">=</span> <span class="n">evals</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">22</span><span class="p">,</span><span class="n">ksize_x</span><span class="p">,</span><span class="n">ksize_y</span><span class="p">).</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

<span class="c1">#%% get me spin expectatin value, see pauli matrix... duh.
</span><span class="n">nband</span> <span class="o">=</span> <span class="mi">16</span> <span class="c1"># check band structure to see which band you want.... duh.
</span><span class="n">exp</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">([</span><span class="n">ksize_x</span><span class="p">,</span><span class="n">ksize_y</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="nb">complex</span><span class="p">)</span>
<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ksize_x</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ksize_y</span><span class="p">):</span>
        <span class="c1"># for non-sprcified non-collinear spin channels, we use default order (orb1_up, orb1_down, orb2_up, orb2_down..)
</span>        <span class="c1"># this default order only works with Wannier90 v2.1.0+
</span>        <span class="n">exp</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">evacs_new</span><span class="p">[</span><span class="n">nband</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]),</span><span class="nb">complex</span><span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">evacs_new</span><span class="p">[</span><span class="n">nband</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>\
                   <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">evacs_new</span><span class="p">[</span><span class="n">nband</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]),</span><span class="nb">complex</span><span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">evacs_new</span><span class="p">[</span><span class="n">nband</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">exp</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">evacs_new</span><span class="p">[</span><span class="n">nband</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]),</span><span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">evacs_new</span><span class="p">[</span><span class="n">nband</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>\
                   <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">evacs_new</span><span class="p">[</span><span class="n">nband</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]),</span><span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">evacs_new</span><span class="p">[</span><span class="n">nband</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">exp</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">evacs_new</span><span class="p">[</span><span class="n">nband</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]),</span><span class="nb">complex</span><span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">evacs_new</span><span class="p">[</span><span class="n">nband</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>\
                   <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">evacs_new</span><span class="p">[</span><span class="n">nband</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]),</span><span class="nb">complex</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">evacs_new</span><span class="p">[</span><span class="n">nband</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>

<span class="c1">#%% plot spin texture
</span><span class="kn">import</span> <span class="nn">matplotlib.transforms</span> <span class="k">as</span> <span class="n">mtransforms</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="c1"># get tran_data function, this will slightly change the direction of the spin vector, but quantitavely its alrigh.
</span><span class="n">trans_data</span> <span class="o">=</span> <span class="n">mtransforms</span><span class="p">.</span><span class="n">Affine2D</span><span class="p">().</span><span class="n">skew_deg</span><span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="o">-</span><span class="mi">15</span><span class="p">).</span><span class="n">rotate_deg</span><span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">)</span> <span class="o">+</span> <span class="n">ax</span><span class="p">.</span><span class="n">transData</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">krange</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span><span class="n">krange</span><span class="o">/</span><span class="n">ksize_x</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">krange</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span><span class="n">krange</span><span class="o">/</span><span class="n">ksize_y</span><span class="p">)</span>

<span class="c1"># M = exp[:,:,2].astype('float64') # use sigma_z as color map
</span><span class="n">M</span> <span class="o">=</span> <span class="n">evals_new</span><span class="p">[</span><span class="n">nband</span><span class="p">,:,:]</span> <span class="c1"># use eigenval as color map
</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="p">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">exp</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">],</span><span class="n">exp</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">],</span><span class="n">M</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">13</span><span class="p">,</span><span class="n">pivot</span><span class="o">=</span><span class="s">'mid'</span><span class="p">,</span><span class="n">transform</span> <span class="o">=</span> <span class="n">trans_data</span><span class="p">)</span>
<span class="c1"># ax.axis([origin[0],krange/2,origin[1],krange/2])
</span><span class="n">ax</span><span class="p">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s">'equal'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">"band# "</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">nband</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">"spintexture_band_"</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">nband</span><span class="p">)</span><span class="o">+</span><span class="s">".png"</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
<span class="c1"># plt.show()
</span>
<span class="c1"># %% plot fermi surface [or 3D band surface]
</span><span class="kn">import</span> <span class="nn">matplotlib.transforms</span> <span class="k">as</span> <span class="n">mtransforms</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">evals_new</span><span class="p">[</span><span class="mi">17</span><span class="p">,:,:],</span>
               <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">krange</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">krange</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span>
               <span class="n">aspect</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">interpolation</span><span class="o">=</span><span class="s">'lanczos'</span><span class="p">,</span><span class="n">origin</span><span class="o">=</span><span class="s">'lower'</span><span class="p">)</span>
<span class="c1"># skew and rotate to match k vectors.
</span><span class="n">trans_data</span> <span class="o">=</span> <span class="n">mtransforms</span><span class="p">.</span><span class="n">Affine2D</span><span class="p">().</span><span class="n">skew_deg</span><span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="o">-</span><span class="mi">15</span><span class="p">).</span><span class="n">rotate_deg</span><span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">)</span> <span class="o">+</span> <span class="n">ax</span><span class="p">.</span><span class="n">transData</span>
<span class="n">im</span><span class="p">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">trans_data</span><span class="p">)</span>
<span class="c1"># reset axes limit
</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">im</span><span class="p">.</span><span class="n">get_extent</span><span class="p">()</span>
<span class="n">ax</span><span class="p">.</span><span class="n">plot</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x1</span><span class="p">],</span> <span class="p">[</span><span class="n">y1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">y1</span><span class="p">],</span> <span class="s">"-"</span><span class="p">,</span>
        <span class="n">transform</span><span class="o">=</span><span class="n">trans_data</span><span class="p">)</span>

<span class="n">ax</span><span class="p">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">"band# "</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">nband</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">"fermi_surface_band_"</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">nband</span><span class="p">)</span><span class="o">+</span><span class="s">".png"</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
</code></pre></div></div>
<p><strong>Result time!</strong></p>

<p class="center"><img src="/assets/img/post_img/2020-06-17-img2.png" alt="" /></p>

<p class="center"><img src="/assets/img/post_img/2020-06-17-img3.png" alt="" /></p>

<p>Here, I‚Äôm plotting the spin textrue for two band (No. 16 and No. 17).
I‚Äôm using the cut plane method here (contrary to the ‚Äòdirect from DFT‚Äô method).
Instead, I‚Äôm showing the eigenvalue of each band with different colour.
<code class="language-plaintext highlighter-rouge">Yellow -&gt; higher in energy</code>, <code class="language-plaintext highlighter-rouge">Black -&gt; lower in energy</code>.</p>

<p>Well, to me, they look <strong>pretty good</strong> and <strong>similar to the DFT result</strong>.</p>

<h2 id="caveats">Caveats</h2>
<p>for Wanneir90 v2.1.0+, I‚Äôve changed the default spinor order in the VASP2WANNIER90 interface.
The new spinor orbital order (example):</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>site 1 projection s  (spin_1)
site 1 projection s  (spin_2)
site 1 projection px (spin_1)
site 1 projection px (spin_2)
site 1 projection py (spin_1)
site 1 projection py (spin_2)
</code></pre></div></div>
<p>the old spinor orbital order (example):</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>site 1 projection s  (spin_1)
site 1 projection px (spin_1)
site 1 projection py (spin_1)
...
site 1 projection s  (spin_2)
site 1 projection px (spin_2)
site 1 projection py (spin_2)
</code></pre></div></div>
<p>And you can always specify which component you want to project! Pretty neat huh?!</p>

<h2 id="input">Input</h2>

<p>I‚Äôve put all input file in a zip file for download: <a href="/assets/other/2020-06-17-W90_spintexture.zip">VASP</a>. Have fun computing!</p>

<h2 id="2020-06-29-update">2020-06-29 update</h2>
<p>I‚Äôve now implemented the <code class="language-plaintext highlighter-rouge">.spn</code> file output. The  <code class="language-plaintext highlighter-rouge">.spn</code> file contains the spin matrix elements:</p>

\[&lt;\psi_{n,k} | \sigma_{x,y,z} | \psi_{m,k} &gt;\]

<p>By rotating this matrix with the U matrix we got from W90, we can calculate the spin expectation value @ each band and k point.</p>

<p>Again, since the Pauli matrix commutes with the Hamiltonian, they share a same set fo eigenvectors. We can use the eigenvectors from diagonalizing the Hamiltonian to get the same stuff.</p>

<p>Here, just to confirm my implementation of <code class="language-plaintext highlighter-rouge">.spn</code> file is correct, I‚Äôll compute the same spin projected bandstructure with Hamiltonian diagonalization and rotating the <code class="language-plaintext highlighter-rouge">.spn</code> file.</p>

<h3 id="directly-from-rotating-spn-matrix">directly from rotating spn matrix</h3>
<p>Just follow the Wannier90‚Äôs example17, you will get:</p>

<p class="center"><img src="/assets/img/post_img/2020-06-17-img4.png" alt="" /></p>

<h3 id="diagonalization-method">diagonalization method</h3>
<p>For this to work, we need:</p>
<ul>
  <li>wannier90.win</li>
  <li>wannier90_centres.xyz</li>
  <li>wannier90_band.dat</li>
  <li>wannier90_band.kpt</li>
  <li>wannier90_hr.dat</li>
</ul>

<p>Code to generate plottable file:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
</span>
<span class="kn">from</span> <span class="nn">pythtb</span> <span class="kn">import</span> <span class="o">*</span> <span class="c1"># import TB model class
</span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">Fe</span><span class="o">=</span><span class="n">w90</span><span class="p">(</span><span class="s">r"output/"</span><span class="p">,</span><span class="s">r"wannier90"</span><span class="p">)</span>

<span class="c1"># get tight-binding model without hopping terms above 0.01 eV
</span><span class="n">my_model</span><span class="o">=</span><span class="n">Fe</span><span class="p">.</span><span class="n">model</span><span class="p">()</span>

<span class="c1">#%%
# solve model on a path and plot it
</span><span class="n">path</span><span class="o">=</span><span class="p">[[</span><span class="mf">0.0000</span><span class="p">,</span> <span class="mf">0.0000</span><span class="p">,</span> <span class="mf">0.0000</span><span class="p">],</span>
      <span class="p">[</span><span class="mf">0.500</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5000</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5000</span><span class="p">],</span>
      <span class="p">[</span><span class="mf">0.7500</span><span class="p">,</span> <span class="mf">0.2500</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2500</span><span class="p">],</span>
      <span class="p">[</span><span class="mf">0.5000</span><span class="p">,</span> <span class="mf">0.0000</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5000</span><span class="p">],</span>
      <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
      <span class="p">[</span><span class="mf">0.500</span><span class="p">,</span> <span class="mf">0.5000</span><span class="p">,</span> <span class="mf">0.5000</span><span class="p">],</span>
      <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
      <span class="p">[</span><span class="mf">0.0000</span><span class="p">,</span> <span class="mf">0.0000</span><span class="p">,</span> <span class="mf">0.0000</span><span class="p">],</span>
      <span class="p">[</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.25</span><span class="p">],</span>
      <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]]</span>
<span class="c1"># labels of the nodes
</span><span class="n">k_label</span><span class="o">=</span><span class="p">(</span><span class="s">r'$\Gamma$'</span><span class="p">,</span><span class="s">r'$H$'</span><span class="p">,</span> <span class="s">r'$P$'</span><span class="p">,</span> <span class="s">r'$N$'</span><span class="p">,</span> <span class="s">r'$\Gamma$'</span><span class="p">,</span><span class="s">r'$H$'</span><span class="p">,</span> <span class="s">r'$N$'</span><span class="p">,</span> <span class="s">r'$\Gamma$'</span><span class="p">,</span><span class="s">r'$P$'</span><span class="p">)</span>
<span class="c1"># call function k_path to construct the actual path
</span><span class="p">(</span><span class="n">k_vec</span><span class="p">,</span><span class="n">k_dist</span><span class="p">,</span><span class="n">k_node</span><span class="p">)</span><span class="o">=</span><span class="n">my_model</span><span class="p">.</span><span class="n">k_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="mi">500</span><span class="p">)</span>

<span class="p">(</span><span class="n">evals</span><span class="p">,</span><span class="n">evacs</span><span class="p">)</span><span class="o">=</span><span class="n">my_model</span><span class="p">.</span><span class="n">solve_all</span><span class="p">(</span><span class="n">k_vec</span><span class="p">,</span><span class="n">eig_vectors</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c1"># #%% get me spin expectatin value, see pauli matrix... duh.
</span><span class="n">exp</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">18</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="nb">complex</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">500</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">18</span><span class="p">):</span>
        <span class="n">exp</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">evacs</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]),</span><span class="nb">complex</span><span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">evacs</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>\
                   <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">evacs</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]),</span><span class="nb">complex</span><span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">evacs</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">exp</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">evacs</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]),</span><span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">evacs</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>\
                   <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">evacs</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]),</span><span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">evacs</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">exp</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">evacs</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]),</span><span class="nb">complex</span><span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">evacs</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>\
                   <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">evacs</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]),</span><span class="nb">complex</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">evacs</span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
<span class="c1">#%% write everything to data
</span><span class="n">f</span><span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"spinexp_band.dat"</span><span class="p">,</span><span class="s">"w+"</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">18</span><span class="p">):</span>
   <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">500</span><span class="p">):</span>
        <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">'%s %s %s</span><span class="se">\n</span><span class="s">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">k_dist</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">evals</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">],</span> <span class="n">np</span><span class="p">.</span><span class="n">real</span><span class="p">(</span><span class="n">exp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mi">2</span><span class="p">])))</span>
   <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>

<span class="n">f</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div></div>
<p>then plot with <code class="language-plaintext highlighter-rouge">gnuplot</code>:</p>

<pre><code class="language-gnuplot">set arrow from      0.34843,     -3.77527557 to       0.34843,     39.45894970 nohead
set arrow from      0.65018,     -3.77527557 to       0.65018,     39.45894970 nohead
set arrow from      0.8244,     -3.77527557 to       0.8244,     39.45894970 nohead
set arrow from      1.07078,     -3.77527557 to       1.07078,     39.45894970 nohead
set arrow from      1.41921,     -3.77527557 to       1.41921,     39.45894970 nohead
set arrow from      1.66559,     -3.77527557 to      1.66559,     39.45894970 nohead
set arrow from      1.91197,     -3.77527557 to      1.91197,     39.45894970 nohead
set arrow from      2.21372,     -3.77527557 to      2.21372,     39.45894970 nohead
unset key
set xrange [0: 2.38794]
set yrange [     -3.77527557 :     39.45894970]
 set xtics (" G "  0.00000," H "  0.34843," P "  0.65018," N "  0.8244," G "  1.07078," H
 "  1.41921," N " 1.66559," G " 1.91197," P " 2.21372," N "  2.38794)
 set palette defined (-1 "blue", 0 "green", 1 "red")
 set pm3d map
 set zrange [-1:1]
 splot "spinexp_band.dat" with dots palette
</code></pre>
<p>And we get:</p>

<p class="center"><img src="/assets/img/post_img/2020-06-17-img5.png" alt="" /></p>

<p>And again, this plot looks exactly like the one we obtained by directly rotating the spn matrix.</p>
:ET